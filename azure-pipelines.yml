trigger:
- main # Specifies the branch that will trigger the pipeline, in this case, the 'main' branch.

pool:
  vmImage: 'ubuntu-latest' # Specifies the virtual machine image to use for the pipeline, here it's the latest Ubuntu.

variables:
  terraformPath: '$(Build.SourcesDirectory)/terraform' # Defines the path to Terraform scripts within the source directory.
  kubernetesPath: '$(Build.SourcesDirectory)/kubernetes' # Defines the path to Kubernetes configuration files within the source directory.
  helmChartPath: '$(Build.SourcesDirectory)/helm' # Path to Helm chart files, including 'values.yaml'.
  terraformVersion: '3.1.x' # Specifies the version of .NET Core SDK to use, likely a typo and should be Terraform version.

stages:
- stage: TerraformProvisioning # First stage for provisioning infrastructure using Terraform.
  jobs:
  - job: ProvisionEC2
    displayName: 'Provision EC2 with Terraform' # Display name for the job in the UI.
    steps:
    - checkout: self # Checks out the source code of the repository.

    - task: UseDotNet@2
      displayName: 'Use .NET Core sdk' # Likely a typo, this step is supposed to set up the Terraform environment.
      inputs:
        packageType: 'sdk'
        version: '$(terraformVersion)'

    - script: |
        cd $(terraformPath)
        terraform init -reconfigure # Initializes Terraform, reconfiguring any backend.
        terraform apply -auto-approve # Applies Terraform configurations without manual approval.
      displayName: 'Terraform Apply'

- stage: KubernetesDeployment
  jobs:
  - job: DeployServices
    displayName: 'Deploy Services to Kubernetes'
    steps:
    - checkout: self

    # Assuming you're deploying to an existing Kubernetes cluster (like AKS)
    # If using Minikube or a different setup, adjust accordingly
    - task: Kubernetes@1
      displayName: 'Set Kubernetes Context'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: '878c5158-df26-4fb2-b4cc-b9999d4617db'

    # Apply the custom ServiceMonitor configuration
    - script: |
        cd $(kubernetesPath)
        kubectl apply -f custom-service-monitor.yaml
      displayName: 'Apply Custom ServiceMonitor'

    # Deploy the monitoring solution using Helm and the custom values.yaml
    - script: |
        helm upgrade --install monitoring prometheus-community/kube-prometheus-stack -f $(helmChartPath)/values.yaml --namespace monitoring
      displayName: 'Deploy Monitoring Solution with Helm'

    # Apply Kubernetes manifests for the web site and monitoring solution
    - script: |
        kubectl apply -f web-site-deployment.yaml
        kubectl apply -f monitoring-solution-deployment.yaml
      displayName: 'Deploy Web and Monitoring Services'
